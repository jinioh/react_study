# Next.js와 타입스크립트를 활용한 모던 개발
## Next.js와 타입스크립트
- Next.js는 리액트 기반으로 하지만, 프론트엔드 뿐만 아니라 서버 기능도 일부 갖고 있음
- 기존 리액트 애플리케이션은 모든 콘텐츠를 클라이언트 사이드인 브라우저에서 렌더링함
- Next.js를 활용해 리액트의 기능을 서버 사이드에서 렌더링되는 애플리케이션으로 확장 가능

### SPA의 등장과 MVC/MVVM 프레임워크
- SPA란 기동 시 한 차례 HTML 전체를 로드하고, 이후에는 사용한 인터렉션에 맞춰 Ajax로 정보를 얻고, 동적으로 페이지를 업데이트 하는 웹 애플리케이션
- 브라우저의 URL을 지정해 서버로부터 콘텐츠를 반환하는 기존 방식이 아니라, SPA에서는 페이지 이동을 클라이언트 사이드에서 수행
- 이때 Ajax를 사용해, 필요할 때 필요한 부분만 데이터를 얻어 뷰를 표시해 오버헤드 줄어듬
- SPA 이전에는 자바 스트럿츠나 루비온레일즈 등 서버 사이드 MVC 프레임워크가 제공하는 뷰 기능을 활용해 일반적으로 UI를 구현
  - 이 형식은 서버 사이드가 뷰(HTML)까지 담당하고, HTML 전체를 클라이언트 사이드에 전달
- SPA가 등장함에 따라 JSON 형식의 API가 서버와 프런트 연결을 담당
- SPA를 도입하는 장점
  - 고성능 애플리케이션 제공
  - 서버 사이드 엔지니어와 프런트엔드 엔지니어의 분업이 쉬어짐
  - JSON API를 통해 느슨한 결합의 설계 가능
  - IOS나 안드로이드 등 네이티브 애플리케이션 클라이언트에 대해서도 API를 통한 느슨한 결합 시스템 구성
- 단점
  - 자바스크립트 읽기와 랜더링이 발생해, 이에 대한 대책이 없으면 초기 표시에 다소 시간이 걸림
  - 학습 비용 발생
  - 프론트 코드량이 많아짐
- SPA는 다음과 같은 기술 요소로 구성
  - URL 경로와 뷰의 라우팅 관리
  - 클라이언트 사이드에서의 브라우저 이력 관리를 통한 페이지 이동
  - 비동기를 통한 데이터 얻기
  - 뷰 렌더링
  - 모듈화된 코드 관리
- 라우팅 라이브러리를 사용함으로써 URL마다 특정한 컴포넌터를 분류하고, 표시를 바꾸어 페이지 이동을 구현하기 위한 작동이 가능

### MVC/MVVM 자바스크립트 라이브러리 난립 시대
- MVVM이란 데이터를 관리하는 Model, 화면 표시와 관련된 View, 데이터와 표시의 가교 역할을 하는 ViewModel을 사용한 아키텍처
- MVVM 모델로부터 뷰로 데이터를 연동하고, 뷰로부터 모델로 데이터의 양방향 바인딩을 수행하는 아키텍처로, DOM 조작 코드를 작성하지 않고도 데이터 변경 변영가능
- 그리고 UI로부터 정보 입력이 데이터와 자동으로 동기화됨에 따라 생산성 높은 프런트 엔드 구현
  - AngularJS, KnockutJs, Riot.js, Vue.js

### 리액트의 등장과 컴포넌트 지향/상태 관리
- 가상 DOM
- 대규모 상태 관리 Flux
  - 양방향 데이터 바인딩을 활용하면 코드가 간략해지는 장점은 있지만, 지나치게 사용하면 어디의 변경이 어디에 영향을 미치는지 추적이 어렵고, 코드의 복잡성이 높아질 수 있음
  - 2014년 페이스북이 플럭스 애플리케이션 아키텍처 제안
  - 플럭스를 사용하면 데이터 흐름을 단방향으로 한정
  - 현재는 플럭스를 발전적으로 계승한 리덕스 라이브러리가 인기

### SSR/SSG의 필요성
- SSR
  - 서버사이드 랜더링은 서버 사이드 자바스크립트 실행 환경에서 요청에 대한 페이지를 생성해 HTML을 반환하는 것
  - 리액트는 보통 사용자의 브라우저가 자바스크립트를 실행하고, JSON을 기반으로 페이지를 구축
  - SSR은 서버 측에서 이를 수행하고, HTML을 생성해 반환
  - 장점
    - 랜더링을 서버 사이드에서 수행한 결과를 반환해, 사이트를 빠르게 표시
    - 서버 사이드에서 콘텐츠를 생성하므로, SPA에서는 복잡했던 SEO를 향상시킬 수 있음
  - 단점
    - Node.js등 서버사이드 자바스크립트 실행 환경 필요
    - 서버 사이드에서 렌더링하므로 서버 CPU 부하 증가
    - 서버와 클라이언트에서 자바스크립트의 로직이 분산될 가능성 있음
- SSG
  - 정적 사이트 생성은 사전에 정적 파일로서 생성, 배포하는 구조

### Next.js 등장
- 기존 모던 웹 애플리케이션을 개발할 땐 르액트 기반의 React Router를 사용해, SPA로 랜더링하는 것이 주류였음
- Next.js는 애플리케이션 특징에 맞춰 페이지의 렌더링을 서버 측에서 수행할 수 있기 때문에, SEO나 성능 측면에서 뛰어남

## 모던 프런트엔드 개발의 설계 사상
### 컴포넌트 지향
- 컴포넌트 설계
  - DRY 프로그래밍 원칙에 따름
  - 장점
    - 부품 재사용을 쉽게 (느슨한 결합)
    - 글로벌을 오염시키지 않음
    - 코드가독성 증가
    - 테스트 쉬워짐
  - 컴포넌트는 가능한 추상적이어야 함
  - 서비스나 기능 고유의 로직을 포함하는 UI 부품을 구현해버리면 재사용성이 낮아져 컴포넌트 장점을 얻을 수 없음
  - 컴포넌트 지향으로 구현한다는 의미는, 가능한 기초적인 컴포넌트 부품을 재사용 가능한 형태로 애플리케이션 콘텍스트에 의존하지 않는 형태로 구현하는 것을 의식함
- 컴포넌트 상태 관리
  - props: 컴포넌트의 외부에서 받을 수 있는 값. 컴포넌트 안에서 무언가 트리거될 때 호출되는 함수도 전달 할 수 있음
  - state: 컴포넌트 내부에서 저장하는 데이터. props와 달리 컴포넌트 외부에서 값을 전달할 수 없으며, 외부로부터 접근할 수 없음
  - props는 단방향 데이터 흐름 구조를 갖는 것이 특징이고, state는 반드시 해당 컴포넌트 자신 및 하위의 컴포넌트에만 영향을 미침
  - 이 원칙을 지킴으로써 데이터를 위에서 아래 방향으로 항상 전달하는 것이 약속되며, 역방향으로는 전달할 수 없으므로, 예상치 못한 부가 작용을 피할 수 있음 (느슨한 결합)
  - 컴포넌트의 state를 업데이트 하려면 훅이라 불리는 기능의 하나인 useState 사용
- 컴포넌트 사이의 데이터 전달
  - 간단한 용도라면 props를 통해 콜백을 주고 받는 방법을 사용할 수 있음
    - 콜백 함수를 사용한 코드는 복잡해지기 마련
  - Flux 또는 Context로 애플리케이션 안의 데이터를 효율적으로 수행
  - Context를 사용하는 목적은 props에 따른 버킷 릴레이를 피하는 것
  - Context는 Provider를 지정한 리액트 컴포넌트 아래의 트리에 대해 '글로벌'로 접근할 수 있는 구조이기 때문에, 너무 많이 사용하면 가독성을 떨어뜨릴 수 있음
- 스토리북: 컴포넌트의 카탈로그화
  - 컴포넌트를 누구나 확인할 수 있는 형태로 카탈로그화함으로써 양쪽의 인식 차이를 줄일 수 있음
  - 장점
    - 컴포넌트 설계를 강제화
    - 컴포넌트 UI를 쉽게 확인
    - 개발자 사이에서의 분업을 쉽게
    - 디자이너, 엔지니어 사이에서 공통 인식을 쉽게 맞출 수 있음
    - 컴포넌트에 전달하는 값을 동적으로 변경해 작동을 확인
    - 컴포넌트 단위 테스트/스냅샷 테스트를 쉽게

### Next.js가 필요해진 이유
- Next.js 개발자들의 사상은 클라이언트와 서버 사이에서 코드를 공유할 수 있는 유니버셜한 자바스크립트 애플리케이션을 만드는 것

## 타입스크립트 기초지식
### 타입스크립트오 자바스크립트의 차이
- 타입스크립트는 자브사크립트에 주로 다음 기능을 추가한 것
  - 타입 정의
  - 인터페이스와 클래스
  - null/undefined-safe
  - 범용적인 클래스나 메서드 타입을 실현하는 제네릭
  - 편집기의 입력 자동 완성
  - 그외, ECMA에서 정의되어 있는 자바스크립트의 최신 사양

## 기본적인 타입 기능
### 타입 추론
### 타입 어서션
- 타입 어서션을 인정하는 것은 대상이 되는 타입보다 구체적이거나 범용적인 타입으로 변환하는 경우
- 타입 어서션은 실행 시 에러를 일으킬 가능성이 있으므로 주의

### 타입 앨리어스
- 이름을 참조해 같은 타입을 여러 차례 재사용 할 수 있음
- 인덱스 타입 앨리어스
  - 키 이름을 명시하지 않고 타입 앨리어스 정의

### 인터페이스
- 타입 앨리어스와 비슷하지만, 보다 확상성이 높은 열린 기능을 갖고 있음
- 나중에 인터페이스를 확장할 수 있다. 타입 앨리아스는 안됨
- 타입스크립트를 설계 사상을 고려했을 때 인터페이스와 타입 앨리어스 기능은 다소 다른 점이 있다
- 인터페이스는 클래스나 데이터의 한쪽 측면을 증어한 타입. 즉, 인터페이스에 매치하는 타입이라도 그 값 이외에 다른 필드나 메서드가 있음을 전재로 함
- 타입 앨리어스는 객체의 타입 자체를 의미
- 객체 그 자체가 아니라 클래스나 객체의 일부 속성이나 함수를 포함하는 일부 작동을 정의할 때는 인터페이스를 사용하는 것이 적합

### 클래스

## 실제 개발 시 중요한 타입
### Enum 타입
- 수치 기반 이외에 문자열 기반 Enum 타입도 사용가능

### 제네릭 타입
- 바깥쪽에서 지정된 타입이 달라도 작동하도로 할 수 있는 범용적인 클래스나 함수를 정의할 때 편리

### Union 타입과 Intersection 타입
- 타입스크립트는 타입을 조합해 사용할 수 있음
- 각각 |와 & 사용
- Intersection 타입은 여러 타입을 병합해 하나로 만든타입을 생성

### 리터럴 타입
- |로 데이터를 구분하는 리터럴 타입을 사용하면 정해진 문자열이나 수치만 대입할 수 있는 타입으로 제어 가능
- 데이터의 상태를 나타내는 값 등에 사용 할 수 이씀
- enum이랑 뭔차이??

### never 타입
- 절대로 발생하지 않는 값의 종류
- 항상 예외를 발생시키는 함수 등에서 절대로 값이 반환되지 않는 반환값의 타입을 never로 지정할 수 있음

## 타입스크립트 테크닉
### 옵셔널 체이닝
- 중첩된 객체의 속성이 존재하는가에 관한 조건 분기를 간단하게 기술할 수 있음
- ?를 사용해 null 또는 undefined가 될 수 있는 객체에 대해 안전하게 처리를 기술

### 논-널 어서션 연산자
- 컴퍼일 옵션 --strictNullChecks를 지정해 컴파일하면, 타입스크립트는 일반적으로 null일 가능성이 있는 객체에 대한 잡근을 에러로 취급
- null이 아님을 나타내고 싶을 때는 논-널 어서션이라는 기능을 명시적으로 컴파일러에게 문제 없음을 전달할 수 있음
- !를 붙임

### 타입 가드
- if나 switch 문의 조건 분기에서 타입 체크를 수행할 때, 해당 조건 분기 블록 이후는 변수의 타입이 필터링되는 추론을 수행
- 실행 시 에러를 발생시키기 쉬운 as를 사용하는 타입 어서션보다 안전하게 타입을 사용한 코드를 작성할 수 있음

### keyof 연산자
- 타입에 keyof를 사용하면 해당 타입이 가진 각 속성의 타입의 Union 타입을 반환
- 객체에 존재하는 키를 사용해 무언가의 함수 처리를 수행하고자 할 때 안전하게 구현할 수 있음

### 인덱스 타입
- 객체의 속성이 변할 때, 모아서 타입을 정의할 수 있음
- 각 속성에 대응하는 타입을 정의할 수 없을 때 간단하게 기술할 수 있음

### readonly
- readonly가 지정된 속성은 변경할 수 없음
- const는 변수의 대입에 대해 수행하는 선언, readony는 객체나 클래스의 속성에 대해 수행하는 선언으로 컴파일 시 에러를 감지할 수 있다. 
- Readonly 타입이라는 제네릭 타입도 있음

### unkown
- any와 마찬가지로 모든 값을 대입할 수 있는 타입
- 대입된 값 상태 그대로는 임의의 함수나 속성으로 접근불가

### 비동기 Async/Await
- 비동기 처리 API인 Promise의 간략한 구문에 해당하는 것이 Async/Await의 기능
- await 구문을 사용하기 위해선 async function 안에서 호출해야 함

### 타입 정의 파일
- 타입스크립트에서는 자바스크립트 라이브러리를 로딩해 실행할 수 있지만, 타입정의 정보가 없을 때는 타입 안전한 코드를 작성할 수 없음
- 그래서 타입스크립트에는 자바스크립트 모듈에 대해, 타입 정보를 부여할 수 있는 타입 정의 파일이라는 구조를 제공
- 타입 정의 파일 도입
  - `@types/[라이브러리명]`으로 공개된 타입 정의 파일을 설치
- 타입 정의 파일 작성
  - 의존하는 자바스크립트의 라이브러리가 타입 정의 파일을 포함하고 있지 않거나, 공개돼 있지 않을 때, 직접 .d.ts라는 확장자를 가진 타입 정의 파일을 설치하고 로딩해 사용

## 타입 스크립트 개발 시 설정
### tsconfig.json
- 컴피일에 필요한 옵션이나 컴파일 대상이 되는 파일의 정보등을 기술
- tsc --init 명령어를 실행하면 기본 tsconfig.json 파일 생성됨
- 프로젝트 루트에 배치

### Prettier
- 공통 코드 포맷
- npm install prettier --save-dev 로 설치
- 프로젝트 디렉터리 아래 .prettierrc 파일이 생성됨
- `npm run prettier-format`명령어로 src 아래의 모든 타입스크립트 소스에 대해 포매팅이 실행됨

### ESLint
- 코드를 해석해 문제가 있는 위치를 지적해 코드 품질을 높이는 데 도움을 줌
- .eslintrc.js 파일

### 컴파일 옵션
- noImplicitAny
  - 암묵적인 any를 사용한 경우 에러발생하도록
- target
  - 타입스크립트가 컴파일을 수행할 때 어떤 버전의 ECMAScript로 출력할 것인지 지정가능

### 코딩 스타일 가이드
- 자바스크립트 표준 스타일
- 에어비앤비 스타일
- 구글 스타일
- TypeScript Deep Dive 스타일

# 리액트/Next.js 기초
## 리액트 입문
### 리액트 시작하기
- npx create-react-app [프로젝트명] --template typescript

### 리액트 기본
