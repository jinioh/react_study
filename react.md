# Next.js와 타입스크립트를 활용한 모던 개발
## Next.js와 타입스크립트
- Next.js는 리액트 기반으로 하지만, 프론트엔드 뿐만 아니라 서버 기능도 일부 갖고 있음
- 기존 리액트 애플리케이션은 모든 콘텐츠를 클라이언트 사이드인 브라우저에서 렌더링함
- Next.js를 활용해 리액트의 기능을 서버 사이드에서 렌더링되는 애플리케이션으로 확장 가능

### SPA의 등장과 MVC/MVVM 프레임워크
- SPA란 기동 시 한 차례 HTML 전체를 로드하고, 이후에는 사용한 인터렉션에 맞춰 Ajax로 정보를 얻고, 동적으로 페이지를 업데이트 하는 웹 애플리케이션
- 브라우저의 URL을 지정해 서버로부터 콘텐츠를 반환하는 기존 방식이 아니라, SPA에서는 페이지 이동을 클라이언트 사이드에서 수행
- 이때 Ajax를 사용해, 필요할 때 필요한 부분만 데이터를 얻어 뷰를 표시해 오버헤드 줄어듬
- SPA 이전에는 자바 스트럿츠나 루비온레일즈 등 서버 사이드 MVC 프레임워크가 제공하는 뷰 기능을 활용해 일반적으로 UI를 구현
  - 이 형식은 서버 사이드가 뷰(HTML)까지 담당하고, HTML 전체를 클라이언트 사이드에 전달
- SPA가 등장함에 따라 JSON 형식의 API가 서버와 프런트 연결을 담당
- SPA를 도입하는 장점
  - 고성능 애플리케이션 제공
  - 서버 사이드 엔지니어와 프런트엔드 엔지니어의 분업이 쉬어짐
  - JSON API를 통해 느슨한 결합의 설계 가능
  - IOS나 안드로이드 등 네이티브 애플리케이션 클라이언트에 대해서도 API를 통한 느슨한 결합 시스템 구성
- 단점
  - 자바스크립트 읽기와 랜더링이 발생해, 이에 대한 대책이 없으면 초기 표시에 다소 시간이 걸림
  - 학습 비용 발생
  - 프론트 코드량이 많아짐
- SPA는 다음과 같은 기술 요소로 구성
  - URL 경로와 뷰의 라우팅 관리
  - 클라이언트 사이드에서의 브라우저 이력 관리를 통한 페이지 이동
  - 비동기를 통한 데이터 얻기
  - 뷰 렌더링
  - 모듈화된 코드 관리
- 라우팅 라이브러리를 사용함으로써 URL마다 특정한 컴포넌터를 분류하고, 표시를 바꾸어 페이지 이동을 구현하기 위한 작동이 가능

### MVC/MVVM 자바스크립트 라이브러리 난립 시대
- MVVM이란 데이터를 관리하는 Model, 화면 표시와 관련된 View, 데이터와 표시의 가교 역할을 하는 ViewModel을 사용한 아키텍처
- MVVM 모델로부터 뷰로 데이터를 연동하고, 뷰로부터 모델로 데이터의 양방향 바인딩을 수행하는 아키텍처로, DOM 조작 코드를 작성하지 않고도 데이터 변경 변영가능
- 그리고 UI로부터 정보 입력이 데이터와 자동으로 동기화됨에 따라 생산성 높은 프런트 엔드 구현
  - AngularJS, KnockutJs, Riot.js, Vue.js

### 리액트의 등장과 컴포넌트 지향/상태 관리
- 가상 DOM
- 대규모 상태 관리 Flux
  - 양방향 데이터 바인딩을 활용하면 코드가 간략해지는 장점은 있지만, 지나치게 사용하면 어디의 변경이 어디에 영향을 미치는지 추적이 어렵고, 코드의 복잡성이 높아질 수 있음
  - 2014년 페이스북이 플럭스 애플리케이션 아키텍처 제안
  - 플럭스를 사용하면 데이터 흐름을 단방향으로 한정
  - 현재는 플럭스를 발전적으로 계승한 리덕스 라이브러리가 인기

### SSR/SSG의 필요성
- SSR
  - 서버사이드 랜더링은 서버 사이드 자바스크립트 실행 환경에서 요청에 대한 페이지를 생성해 HTML을 반환하는 것
  - 리액트는 보통 사용자의 브라우저가 자바스크립트를 실행하고, JSON을 기반으로 페이지를 구축
  - SSR은 서버 측에서 이를 수행하고, HTML을 생성해 반환
  - 장점
    - 랜더링을 서버 사이드에서 수행한 결과를 반환해, 사이트를 빠르게 표시
    - 서버 사이드에서 콘텐츠를 생성하므로, SPA에서는 복잡했던 SEO를 향상시킬 수 있음
  - 단점
    - Node.js등 서버사이드 자바스크립트 실행 환경 필요
    - 서버 사이드에서 렌더링하므로 서버 CPU 부하 증가
    - 서버와 클라이언트에서 자바스크립트의 로직이 분산될 가능성 있음
- SSG
  - 정적 사이트 생성은 사전에 정적 파일로서 생성, 배포하는 구조

### Next.js 등장
- 기존 모던 웹 애플리케이션을 개발할 땐 르액트 기반의 React Router를 사용해, SPA로 랜더링하는 것이 주류였음
- Next.js는 애플리케이션 특징에 맞춰 페이지의 렌더링을 서버 측에서 수행할 수 있기 때문에, SEO나 성능 측면에서 뛰어남

## 모던 프런트엔드 개발의 설계 사상
### 컴포넌트 지향
- 컴포넌트 설계
  - DRY 프로그래밍 원칙에 따름
  - 장점
    - 부품 재사용을 쉽게 (느슨한 결합)
    - 글로벌을 오염시키지 않음
    - 코드가독성 증가
    - 테스트 쉬워짐
  - 컴포넌트는 가능한 추상적이어야 함
  - 서비스나 기능 고유의 로직을 포함하는 UI 부품을 구현해버리면 재사용성이 낮아져 컴포넌트 장점을 얻을 수 없음
  - 컴포넌트 지향으로 구현한다는 의미는, 가능한 기초적인 컴포넌트 부품을 재사용 가능한 형태로 애플리케이션 콘텍스트에 의존하지 않는 형태로 구현하는 것을 의식함
- 컴포넌트 상태 관리
  - props: 컴포넌트의 외부에서 받을 수 있는 값. 컴포넌트 안에서 무언가 트리거될 때 호출되는 함수도 전달 할 수 있음
  - state: 컴포넌트 내부에서 저장하는 데이터. props와 달리 컴포넌트 외부에서 값을 전달할 수 없으며, 외부로부터 접근할 수 없음
  - props는 단방향 데이터 흐름 구조를 갖는 것이 특징이고, state는 반드시 해당 컴포넌트 자신 및 하위의 컴포넌트에만 영향을 미침
  - 이 원칙을 지킴으로써 데이터를 위에서 아래 방향으로 항상 전달하는 것이 약속되며, 역방향으로는 전달할 수 없으므로, 예상치 못한 부가 작용을 피할 수 있음 (느슨한 결합)
  - 컴포넌트의 state를 업데이트 하려면 훅이라 불리는 기능의 하나인 useState 사용
- 컴포넌트 사이의 데이터 전달
  - 간단한 용도라면 props를 통해 콜백을 주고 받는 방법을 사용할 수 있음
    - 콜백 함수를 사용한 코드는 복잡해지기 마련
  - Flux 또는 Context로 애플리케이션 안의 데이터를 효율적으로 수행
  - Context를 사용하는 목적은 props에 따른 버킷 릴레이를 피하는 것
  - Context는 Provider를 지정한 리액트 컴포넌트 아래의 트리에 대해 '글로벌'로 접근할 수 있는 구조이기 때문에, 너무 많이 사용하면 가독성을 떨어뜨릴 수 있음
- 스토리북: 컴포넌트의 카탈로그화
  - 컴포넌트를 누구나 확인할 수 있는 형태로 카탈로그화함으로써 양쪽의 인식 차이를 줄일 수 있음
  - 장점
    - 컴포넌트 설계를 강제화
    - 컴포넌트 UI를 쉽게 확인
    - 개발자 사이에서의 분업을 쉽게
    - 디자이너, 엔지니어 사이에서 공통 인식을 쉽게 맞출 수 있음
    - 컴포넌트에 전달하는 값을 동적으로 변경해 작동을 확인
    - 컴포넌트 단위 테스트/스냅샷 테스트를 쉽게

### Next.js가 필요해진 이유
- Next.js 개발자들의 사상은 클라이언트와 서버 사이에서 코드를 공유할 수 있는 유니버셜한 자바스크립트 애플리케이션을 만드는 것

## 타입스크립트 기초지식
### 타입스크립트오 자바스크립트의 차이
- 타입스크립트는 자브사크립트에 주로 다음 기능을 추가한 것
  - 타입 정의
  - 인터페이스와 클래스
  - null/undefined-safe
  - 범용적인 클래스나 메서드 타입을 실현하는 제네릭
  - 편집기의 입력 자동 완성
  - 그외, ECMA에서 정의되어 있는 자바스크립트의 최신 사양

## 기본적인 타입 기능
### 타입 추론
### 타입 어서션
- 타입 어서션을 인정하는 것은 대상이 되는 타입보다 구체적이거나 범용적인 타입으로 변환하는 경우
- 타입 어서션은 실행 시 에러를 일으킬 가능성이 있으므로 주의

### 타입 앨리어스
- 이름을 참조해 같은 타입을 여러 차례 재사용 할 수 있음
- 인덱스 타입 앨리어스
  - 키 이름을 명시하지 않고 타입 앨리어스 정의

### 인터페이스
- 타입 앨리어스와 비슷하지만, 보다 확상성이 높은 열린 기능을 갖고 있음
- 나중에 인터페이스를 확장할 수 있다. 타입 앨리아스는 안됨
- 타입스크립트를 설계 사상을 고려했을 때 인터페이스와 타입 앨리어스 기능은 다소 다른 점이 있다
- 인터페이스는 클래스나 데이터의 한쪽 측면을 증어한 타입. 즉, 인터페이스에 매치하는 타입이라도 그 값 이외에 다른 필드나 메서드가 있음을 전재로 함
- 타입 앨리어스는 객체의 타입 자체를 의미
- 객체 그 자체가 아니라 클래스나 객체의 일부 속성이나 함수를 포함하는 일부 작동을 정의할 때는 인터페이스를 사용하는 것이 적합

### 클래스

## 실제 개발 시 중요한 타입
### Enum 타입
- 수치 기반 이외에 문자열 기반 Enum 타입도 사용가능

### 제네릭 타입
- 바깥쪽에서 지정된 타입이 달라도 작동하도로 할 수 있는 범용적인 클래스나 함수를 정의할 때 편리

### Union 타입과 Intersection 타입
- 타입스크립트는 타입을 조합해 사용할 수 있음
- 각각 |와 & 사용
- Intersection 타입은 여러 타입을 병합해 하나로 만든타입을 생성

### 리터럴 타입
- |로 데이터를 구분하는 리터럴 타입을 사용하면 정해진 문자열이나 수치만 대입할 수 있는 타입으로 제어 가능
- 데이터의 상태를 나타내는 값 등에 사용 할 수 이씀
- enum이랑 뭔차이??

### never 타입
- 절대로 발생하지 않는 값의 종류
- 항상 예외를 발생시키는 함수 등에서 절대로 값이 반환되지 않는 반환값의 타입을 never로 지정할 수 있음

## 타입스크립트 테크닉
### 옵셔널 체이닝
- 중첩된 객체의 속성이 존재하는가에 관한 조건 분기를 간단하게 기술할 수 있음
- ?를 사용해 null 또는 undefined가 될 수 있는 객체에 대해 안전하게 처리를 기술

### 논-널 어서션 연산자
- 컴퍼일 옵션 --strictNullChecks를 지정해 컴파일하면, 타입스크립트는 일반적으로 null일 가능성이 있는 객체에 대한 잡근을 에러로 취급
- null이 아님을 나타내고 싶을 때는 논-널 어서션이라는 기능을 명시적으로 컴파일러에게 문제 없음을 전달할 수 있음
- !를 붙임

### 타입 가드
- if나 switch 문의 조건 분기에서 타입 체크를 수행할 때, 해당 조건 분기 블록 이후는 변수의 타입이 필터링되는 추론을 수행
- 실행 시 에러를 발생시키기 쉬운 as를 사용하는 타입 어서션보다 안전하게 타입을 사용한 코드를 작성할 수 있음

### keyof 연산자
- 타입에 keyof를 사용하면 해당 타입이 가진 각 속성의 타입의 Union 타입을 반환
- 객체에 존재하는 키를 사용해 무언가의 함수 처리를 수행하고자 할 때 안전하게 구현할 수 있음

### 인덱스 타입
- 객체의 속성이 변할 때, 모아서 타입을 정의할 수 있음
- 각 속성에 대응하는 타입을 정의할 수 없을 때 간단하게 기술할 수 있음

### readonly
- readonly가 지정된 속성은 변경할 수 없음
- const는 변수의 대입에 대해 수행하는 선언, readony는 객체나 클래스의 속성에 대해 수행하는 선언으로 컴파일 시 에러를 감지할 수 있다. 
- Readonly 타입이라는 제네릭 타입도 있음

### unkown
- any와 마찬가지로 모든 값을 대입할 수 있는 타입
- 대입된 값 상태 그대로는 임의의 함수나 속성으로 접근불가

### 비동기 Async/Await
- 비동기 처리 API인 Promise의 간략한 구문에 해당하는 것이 Async/Await의 기능
- await 구문을 사용하기 위해선 async function 안에서 호출해야 함

### 타입 정의 파일
- 타입스크립트에서는 자바스크립트 라이브러리를 로딩해 실행할 수 있지만, 타입정의 정보가 없을 때는 타입 안전한 코드를 작성할 수 없음
- 그래서 타입스크립트에는 자바스크립트 모듈에 대해, 타입 정보를 부여할 수 있는 타입 정의 파일이라는 구조를 제공
- 타입 정의 파일 도입
  - `@types/[라이브러리명]`으로 공개된 타입 정의 파일을 설치
- 타입 정의 파일 작성
  - 의존하는 자바스크립트의 라이브러리가 타입 정의 파일을 포함하고 있지 않거나, 공개돼 있지 않을 때, 직접 .d.ts라는 확장자를 가진 타입 정의 파일을 설치하고 로딩해 사용

## 타입 스크립트 개발 시 설정
### tsconfig.json
- 컴피일에 필요한 옵션이나 컴파일 대상이 되는 파일의 정보등을 기술
- tsc --init 명령어를 실행하면 기본 tsconfig.json 파일 생성됨
- 프로젝트 루트에 배치

### Prettier
- 공통 코드 포맷
- npm install prettier --save-dev 로 설치
- 프로젝트 디렉터리 아래 .prettierrc 파일이 생성됨
- `npm run prettier-format`명령어로 src 아래의 모든 타입스크립트 소스에 대해 포매팅이 실행됨

### ESLint
- 코드를 해석해 문제가 있는 위치를 지적해 코드 품질을 높이는 데 도움을 줌
- .eslintrc.js 파일

### 컴파일 옵션
- noImplicitAny
  - 암묵적인 any를 사용한 경우 에러발생하도록
- target
  - 타입스크립트가 컴파일을 수행할 때 어떤 버전의 ECMAScript로 출력할 것인지 지정가능

### 코딩 스타일 가이드
- 자바스크립트 표준 스타일
- 에어비앤비 스타일
- 구글 스타일
- TypeScript Deep Dive 스타일

# 리액트/Next.js 기초
## 리액트 입문
### 리액트 시작하기
- npx create-react-app [프로젝트명] --template typescript

### 리액트 기본
- 브라우저에서 페이지가 표시될 때, 다음의 순서를 통해 실제 리액트에 작성된 내용이 반영됨
  - public/index.html을 로딩해 브라우저에 그림
  - 브라우저가 자바스크립트 코드를 얻어, 리액트를 사용한 코드의 실행을 시작
  - render()에 주어진 App을 root 객체 작성 시 주어진 root라는 ID를 가진 요소 아래 그림
- 리액트의 기본 키워드
  - 웹 페이지에 리액트로 생성한 내용을 표시하려면 ReacDOM.createRoot에 컨테이너를 전달해 root 객체를 생성하고, render 메서드에 요소를 전달

## 리액트에서의 컴포넌트
- 컴포넌트로 구현한 내용은 최종적으로 브라우저에서는 대응하는 HTML 태그 등으로 변환되어 표시됨
- JSX 코드는 브라우저에서는 직접 해석할수 없으므로, 웹팩에 의해 자바스크립트 코드로 변환됨
- 이때 JSX로 구현된 컴포넌트는 자바스크립트의 객체로 표현됨
- 변환된 자바스크립트 코드를 브라우저가 읽어 실행하고 화면을 그리기 시작
- 리액트의 화면 그리기 엔진에서는 먼저 가상 DOM을 구현함
- 그리고 앞에서 구현할 떄의 가상 DOM과 비교해, 차이가 있는 부분만 실제 DOM을 업데이트

### 리액트 요소
- JSX는 중괄호{}를 사용해 자바스크립트의 값을 삽입할 수 있음

### 컴포넌트
- 함수나 클래스를 사용해 구현하나, 현재는 주로 함수 컴포넌트를 사용
- 컴포넌트 이름은 대문자로 시작
- 컴포넌트에 외부에서 값을 전달하려면 props를 사용
  - props는 컴포넌트를 사용한 부모로부터 전달되는 데이터
  - 컴포넌트를 사용하는 측은 같은 이름으로 데이터를 전달
- props는 부모로부터 자식에게 한 방양으로 데이터를 전달하는 것
- props의 내용을 자식이 치환할 수 없고, 시도하면 에러 발생

## 리액트에서의 타입
- 함수 컴포넌트는 임의의 객체를 props로서 인수로 가지며, JSX.Element 타입의 값을 반환하는 함수가 됨
- 그러므로 인수인 props에 타입 애터테이션을 붙여 부모 컴포넌트로부터 받을 수 있는 값을 제한할 수 있음

## Context
- 데이터를 전달하는 또 한가지 방법으로 Context가 있음
- Context를 사용하면 데이터를 부모로부터 직접 전달하지 않아도 컴포넌트가 필요한 데이터를 참조할 수 있음
- 예를 들어 로그인한 사용자 정보는 여러 컴포넌트에서 사용될 수 있어 props보단 Context 사용
- Provider와 Consumer라는 2개의 컴포넌트를 사용
- 먼저 createContext()로 Context 작성
- 데이터를 전달할 때는 Context.Provider 컴포넌트의 props인 Value에 데이터를 전달
- 데이터를 참조할 때는 Context.Consumer 컴포넌트를 추가하고, 그 자식 요소로서 함수를 지정하면 인수로부터 데이터를 참조 할 수 있음

## React Hooks
- 함수 컴포넌트 안의 상태난 라이프사이클을 다루기 위한 기능
- 컴포넌트 안의 상태와 로직을 훅으로 추출해, 컴포넌트 코드를 깔끔하게 유지할 수 있음
### useState와 useReducer - 상태 훅
- 이 훅들을 사용하면 컴포넌트는 내부 상태를 가지며, 해당 상태의 변화에 따라 표시를 변경할 수 있음
- useState
  - const [상태, 업데이트 함수] = useState(초기값)로 하나의 새로운 상태를 작성
  - 첫 번째 인수에 전달한 값이 초기 상태가 됨
  - 반환값은 배열임
    - 배열의 첫 번째에 현재 상태를 유지할 변수
    - 두 번째에 업데이트 함수를 입력
  - 업데이트 함수를 호출하면 상태가 바뀌고, 훅이 있는 컴포넌트는 다시 그려짐
  - 업데이트 함수를 호출하라 때는 인수에 값을 전달하는 방법과, 함수를 전달하는 방법이 있음
    - 값을 전달하면 해당 값이 다음 상태가 되며, 함수를 전달하면 함수의 반환값이 다음 상태가 됨
  - 새로 업데이트 할 값이 이전 스테이트와 연관되어 있다면 setState에 콜백함수를 넣는게 좋음. 콜백 인자로는 이전 값들이 들어가게됨
  - 초기값을 가져올때 useState에 무거운 작업이 발생한다면 콜백함수를 사용해 1번만 호출되도록
- useReducer
  - 상태를 다루기위한 또 하나의 훅
  - 복잡한 상태 전이를 간단하게 기술 할 수 있음
  - 업데이트 함수(dispatch)에 action이라 불리는 데이터를 전달
  - reducer(현재상태, action) { return 다음상태 }
  - const [현재상태, dispatch함수] = useReducer(reducer, reducer에 전달되는 초기 상태) 
  - reducer가 현재 상태와 action을 기반으로 다음 상태를 결정
  - Reducer, Dispatch, Action 3가지로 이뤄짐
    - Reducer: State를 업데이트 해줌
    - Dispatch: 요구하는 것
    - Action: 요구의 내용
    - Dispatch(Action) --> Reducer(State, Action) --> State Update
  - state 바뀔때마다 리랜더링함
  - reducer는 전달받은 action으로만 동작. action에 if 또는 switch문이 들어감
  - 또한 배열아나 객체 등의 여러 데이터를 모은 것을 상태로 다루는 경우 많이 사용
  - useState는 업데이트 함수에 다음 상태를 직접 전달했지만, useReducer에서는 업데이트 함수(dispatch)에 action이라는 데이터를 전달
  - useReducer()의 반환값 배열의 첫 번째는 현재 상태, 두 번째는 dispatcher 함수
  - useReducer의 첫 번째 인수에는 reducer함수, 두 번째에는 초깃값을 전달
  - setState()에 비해, 상태 업데이트를 호출하는 방법은 구체적인 상태에 의존하지 않기 때문에 코드를 간단하게 유지할 수 있음
  - 상태를 업데이트하는 로직을 컴포넌트 밖의 함수로 추출하기 때문에 테스트도 쉬워짐

### useCallback과 useMemo - 메모이제이션 훅
- 값이나 함수를 유지하고, 불필요한 자식 요소의 렌더링이나 계산을 억제하기 위해 사용
- 부모 컴포넌트가 다시 그려지면 무조건 자식 컴포넌트는 다시 그려짐
- 다시 그리기가 전파되는 것을 막기 위해, 메모이제이션 컴포넌트를 사용
- 메모이제이션 컴포넌트는 부모 컴포넌트에서 화면 다시 그리기가 발생했을 때도, props나 context 값이 바뀌지 않은 경우 화면 다시 그리기가 발생하지 않음
- 메모이제이션 컴포넌트는 함수 컴포넌트를 memo 함수로 감싸서 작성할 수 있음
- 메모이제이션 컴포넌트에 함수나 객체를 전달하면, 다시 부모의 화면이 다시 그려질 때 컴포넌트 역시 다시 그려짐
  - 저장하고 있는 주소가 바뀌어서
- useCallback이나 useMemo는 함수나 값을 메모이제이션 함
- useCallback
  - 함수를 메모이제이션 하기 위한 훅
  - 다시 그려지면 함수 객체도 재할당 됨 --> 다른메모리에 저장 --> useEffect를 쓰면 다시 호출되는 문제
  - 인자로 넘긴 콜백함수 자체를 메모이제이션
  - 2개 인자 받음
    - 첫 번째 콜백함수
    - 두 번째 의존배열
  - 함수가 화면을 다시 그릴 떄, useCallback()은 의존배열의 값을 비교
- useMemo
  - 값을 메모이제이션 (동일한 값을 재사용할 때)
  - 어떠한 조건이 만족했을 때만 실행할수 있게
  - 함수형 컴포넌트는 랜더링 --> Component 함수 호출 --> 모든 내부 변수 초기화
  - 처음 계산된 결과를 메모리에 저장 후 재사용
  - Object를 배열 인자로 받을 때 useEffect 사용하면, 주의! (재호출 될때 주소값이 달라져서 매번 호출 될 수 있음)
    - 이때 useMemo사용
  - 2개 인자 받음
    - 첫번째 콜백함수 (유즈메모가 리턴하는 값. 값을 생성하는 함수)
    - 두번째 의존성배열: 요소의 값이 업데이트 될 때 콜백함수 실행
  - 값을 메모이제이션함으로써 자식 요소의 그리기를 억제할 뿐만 아니라, 불필요한 계산도 억제하기 위해 사용
  - 꼭 필요할 때만 사용
- React.memo
  - 리액트에서 제공하는 고착 컴포넌트
  - 고착 컴포넌트는 하나의 함수, 컴포넌트를 인자로 받아서 또다른 컴포넌트 반환
  - 랜더링이 될 상황에 놓일 때마다 Props Check를 함
  - 오직 Props 변화에만 의존하는 최적화 방법
  - props에 변화가 있을 때 랜더링. 아니면 재사용
  - 꼭 필요할 때만 사용
    - 컴포넌트가 같은 Props로 자주 랜더링 될 때
    - 컴포넌트가 렌더링이 될때마다 복잡한 로직을 처리해야할 때

### useEffect와 useLayoutEffect - 부가 작용 훅
- 부가작용을 위한 훅
- 부가작용은 컴포넌트의 그리기와는 직접적인 관계가 없는 처리를 말함
- useEffect
  - 부가 작용을 실행하기 위해 사용하는 훅
  - props나 state가 업데이트되고, 다시 그리기가 완료된 후 처리가 실행됨
  - 의존 배열을 지정해 특정 데이터가 변화할 때만 처리하도록 설정할 수 있음
  - Mount, Update, Unmount와 관련
  - 인자로 콜백함수를 받음. 원하는 작업을 작성
  - 콜백함수만 받는거나, 콜백함수 + 배열을 받거나
    - 첫번째는 랜더링 될때 마다 실행
    - 두 번째는 맨처음 화면 랜더링 될때와 value 값이 바뀔때 실행
        - 빈배열 전달하면 처음에 랜더링 될 때만 실행
        - 여기서 배열은 디팬던시 배열임
  - return 값을 작성해주면 언마운트 될 때 실행 됨(클린업 함수). 정리 작업을 작성할 수 있음
    - useEffect가 실행되기 직전 또는 언마운트 시 실행됨
- useLayoutEffect (*다시보기*)
  - 부가 작용을 실행하기 위한 훅이지만, useEffect와 실행 시점이 다름
  - useEffect는 화면 그리기 함수가 실행되고, DOM이 업데이트되고, 화면에 실제로 그려진 뒤에 실행됨
  - useLayoutEffect는 DOM이 업데이트된 후, 화면에 실제로 그려지기 전에 실행됨
  - useLayoutEffect로 실행하는 처리는 동기적으로 실행되므로, 무거운 처리를 실행하면 화며녀 그리기가 지연되어 주의해야 함
- 리액트 18에서의 작동
  - 리액트 18에서 `<React.StrintMode>` 아래의 컴포넌트 안에서 선언된 useEffect, useLayoutEffect는 안전하지 않은 부가 작요을 발견하기 위해, 컴포넌트는 화면을 2번 그림
  - 그래서 빈 배열을 전달했을 때, 마운트 시에 useEffect나 useLayoutEffect가 2번 호출 됨
  - 또한 클린업 함수도 1버 호출 됨
  - 1번만 실행되도록 보장할 때는, useRef등을 사용해 앞에서 실행 유무를 지정해 대처할 수 있음
  - 또한 프로덕션 환경이나 `<React.StrintMode>`로 감싸지 않은 컴포넌트는 이렇게 작동하지 않음


### useContext - Context를 위한 훅
- useContext
  - Context로부터 값을 참조하기 위한 훅
  - useContext 인수에 Context를 전달함으로써, 해당 Context 값을 얻을 수 있음
  - 전역적인 데이터를 props로 전달하면 힘들 수 있음
    - Prop Drilling
  - 상위에서 사용하고 싶은 하위 컴포넌트에 방송해 줄 수 있음
  - Context는 꼭 필요할 떄만 사용
    - Context를 사용하면 컴포넌트를 재사용하기 어려워 질 수 있음
    - Prop Drilling을 피하기 위한 목적이라면 Component Composition을 먼저 고려

### useRef와 useImpreativeHandle - ref 훅
- useRef는 ref 객체를 작성함
- ref는 커게 2가지 방법으로 사용할 수 있음
  - 데이터 저장
  - DOM 참조
- 함수 컴포넌트 안에서 데이터를 저장하기 위해서는 useState나 useReducer가 있지만, 이들은 상태를 업데이트할 때 화면을 다시 그리게 됨
- ref 객체에 저장된 값은 업데이트되더라도 화면을 다시 그리지 않음
  - 그러므로 화면 그리기와 관계없는 데이터를 저장할 때 사용
- DOM참조는 ref는 컴포넌트에 전달하면, 이 요소가 마운트될 때, ref.current에 DOM 참조가 설정되어, DOM 함수등을 호출할 수 있음
- useRef(value)
  - ref 오브젝트를 반환 {current: value}
  - unmout 될 때 까지 값을 유지할 수 있음
    - 일반 변수랑 다른점은 일반 변수는 화면이 초기화 될 때 값도 초기화됨
  - ref가 수정되도 다시 랜더링 하지 않음
    - 무한 랜더링 방지할 수 있음
    - 값의 변화가 랜더링을 발생시키고 싶지 않을 때 편리
  - 유용한 상황
    - 저장공간으로 사용: Ref가 변화 --> No 렌더링 --> 변수들의 값 유지 (변경시 랜더링이 발생하지 말아야 할 상황을 다룰 때)
    - DOM 요소에 접근
- useImperativeHandle
  - 이 컴포넌트에 ref가 전달될 때, 부모의 ref에 대입될 값을 설정할 때 사용
  - useImperativeHandle를 사용함으로써, 자식 컴포넌트가 가진 데이터를 참조하거나, 자식 컴포넌트에 정의도니 함수를 부모로부터 호출할 수 있음
  - 첫 번째 인수에는 부모로부터 전달된 ref를 전달하고, 두 번째 인수에서는 객체가 반환하는 함수를 정의
  - 이 함수에서 반환값이 부모의 ref에 설정됨
  - 세번째 인수에는 의존 배열을 전달 할 수 있음

### 커스텀 훅과 useDebugValue
- 루프, 조건 분기, 콜백 함수 안에서는 훅을 호출할 수 없음
- 훅을 사용하는 함수를 새롭게 정의하고, 그것을 함수 컴포넌트의 톱레벨에서 호출할 수 있음
- 이런 함수를 구현함으로써 여러 훅을 조합한 커스텀 훅을 구현할 수 있음
- 커스텀 훅의 이름은 관습적으로 use에서 시작함

## Next.js 입문
### 프로젝트 셋업
- create-next-app <프로젝트명>으로 새로운 Next.js 프로젝트 생성
  - --ts를 옵션으로 타입스크립트용 프로젝트
- build는 프로젝트를 빌드하고 결과를 .next 아래 저장하고 star를 사용해 .next으 ㅣ데이터를 기반으로 서버를 기동

### 프로젝트 기본 구성
- pages 디렉터리에는 페이지 컴포넌트나 API 코드가 배치됨
- pages/index.tsx는 브라우저에 표시된 페이지의 내용을 컴포넌트로 구현한 것
- public 디렉토리에는 정적 파일을 배치
- styles 디렉토리에는 css 파일 배치 (없는데???)
  - *.module.css는 컴포넌트를 정의하는 파일에서 읽으며, 클래스명이나 ID가 다른 파일에서 정의한 것과 충돌하느 ㄴ것을 방지하기 위해 파일마다 클래스명과 ID 접두사 또는 접미사를 빌드 시 자동으로 부여

## Next.js 랜더링 방법
- Next.js에서는 4가지 랜더링 방법을 사용할 수 있음
### 정적 사이트 생성(SSG)
- SSG에서는 빌드 시 API 등으로부터 데이터를 얻어, 페이지를 그려 정적 파일로 생성
- 빌드 시 getStaticProps라는 함수가 호출되며, 그 함수 안에서 API 호출 등을 수행하고, 페이지를 그리는데 필요한 props를 반환
- 그 뒤 이 props를 페이지 컴포넌트에 전달해 화면을 그리고 그린 결과를 정적 파일 형태로 빌드 결과로 저장
- SSG는 접근 시에는 정적 파일을 클라이언트에 전달할 뿐이므로 초기 화면 그리기가 빠름
- 실시간 컨텐츠에는 적합하지 않음 (빌드시에만 그리므로)
- 빌드 후 표시 내용이 업데이트되지 않는 페이지나 초기 화면 그리기 이후에 데이터를 표시할 수 있는 페이지에 적합
### 클라이언트 사이드 랜더링(CSR)
- 빌드 시에 데이터를 얻지 않고, 페이지를 화면에 그려 저장
- 그리고 브라우저에서 초기 화면 그리기를 한 뒤, 비동기로 데이터를 얻어 추가 데이터를 표시
- 페이지를 그리기 위해 필요한 데이터는 나중에 얻어 반영하기 때문에, SEO에는 그다지 유효하지 않음
- 초기 화면을 그리는 것이 중요하지 않고, 실시간성이 중요한 페이지에 적합

### 서버 사이드 랜더링(SSR)
- SSR에서는 페이지 접근이 발생할 때마다 서버에 getServerSideProps를 호출하고, 그 결과를 props 기반으로 페이지를 서버 측에서 그려 클라이언트에 전달
- 항상 최신 데이터를 기반으로 페이지를 초기화면을 그릴 수 있어, SEO에 대한 유효성을 기대할 수 있음
- 하지만 다른 방법들에 비해 지연이 높으질 가능성 있음
- 최신 가격이 표시되는 제품 페이지 등, 항상 최신 데이터를 표시하고자 하는 경우 적합

### 점진적 정적 재생성(ISR)
- 페이지 접근이 발생하면 사전에 랭더링해 서버에 저장한 페이지의 데이터를 클라이언트에 전달
- 이 데이터에 유효 기간을 설정할 수 있고, 유효 기간이 지난 상태에서 접근이 발생하면 백그라운드에서 다시 getStaticProps를 실행해 화면을 그리고, 서버에 저장된 페이지를 업데이트

## 페이지와 랜더링 방법
- pages 디렉터리 아래에 배치된 tsx 등의 파일은 파일 1개가 페이지 1개에 대응함
- 이 파일들은 리액트 컴포넌트를 반환하는 함수를 정의하고, 그 함수를 익스포트 함
  - 관습적으로 익스포트한 함수와 피일명은 동일하게 작성

### Next.js의 페이지와 데이터 취득
- pages는 그 종류에 따라 데이터 취득에 사용할 수 있는 함수가 다름
- 페이지 사이에서 공통으로 사용하느 코드나 UI 부분은 pages 디렉터리 밖에서 정의하고 임포트해 사용할 수 있음

### SSG를 통한 페이지 구현
- NextPage는 pages를 위한 타입임

### getStaticProps를 사용한 SSG를 통한 페이지 구현
- 파일 안에 getStaticProps라는 함수 정의하고 익스포트 하면, 해당 함수는 빌드 시 실행됨
- 반환값으로 props를 반환할수 있고, 그 값이 페이지 컴포넌트에 전달되어 그려짐
- getStaticProps는 export 해야하며, 비동기 함수로 async와 함께 정의해야 함
- npm run dev를 사용해 개발 서버를 실행하는 경우 최신 코드를 사용해 페이지를 표시하기 때문에, 요청이 있을 때마다 getStaticProps가 실행되고 서버에서 페이지를 생성함
- getStaticProps의 인수에는 context가 부여됨
- context에는 빌드 시 사용할 수 있는 데이터가 포함돼 있음
  - context.locale과 같은 형태로 접근함
  - 아래는 관련 파라미터
    - params: 경로 파라미터
    - locale: 현재 로케일 정보
    - locales: 지원하는 로케일 배열
    - defaultLocale: 기본 로케일
    - preview: Preview Mode 여부
    - previewData: 

### getStaticPaths를 사용한 여러 페이지의 SSG
- 동적 라우팅 기능으로 경로 파라미터를 사용해 여러 페이지를 1개의 파일로 생성할 수 잇음
- 동적 라우팅은 다음 2가지 요소로 구성됨
  - `[파라미터].tsx`와 같이 []로 감싼 특별한 파일명
  - getStaticProps에 맞춰 getStaticPaths를 사용
- getStaticPath는 getStaticProps 실행 전에 호출되는 함수로, 생성할 페이지의 경로 파라미터의 조합과 폴백을 반환
  - paths는 경로 파라미터의 조합을 나타내고, 배열의 각 요소가 1개의 페이지에 대응
  - fallback은 getStaticPath가 생성하는 페이지가 존재하지 않은 경우 처리를 기술
- paths의 각요소에 대해 getStaticProps가 호출되고 페이지가 생성됨
- getStaticProps에는 context인 params로부터 경로 파라미터를 참조할 수 있음
- GetStaticPaths에서 fallback을 false로 설정하면 paths에 정의된 페이지 외에는 404를 표시함
- fallback에 true를 지정하면, 가장 첫 번째 방문한 사용자에 대해서는 폴백 페이지를 처음에 표시함
- 서버사이드에서는 요청의 경로에 대해 getStaticProps를 실행함
- getStaticProps가 반환한 props는 페이지를 표시하고 있는 클라이언트에 전송되고 화면을 그림
- 서버 사이드에서 props를 기반으로 페이지를 그리고 그 결과를 저장, 그 뒤 동일한 경로에 대한 요청이 오면 저장했던 페이지를 반환

### SSR을 통한 페이지 구현
- SSG에서는 페이지를 그리기 전 getServerSideProps를 호출하며, 이 함수가 반환한 props를 기반으로 페이지를 그림
- getServerSideProps의 인수인 context에는 getStaticProps의 context에서 참조할 수 있는 데이터와 함께, 요청 정보 등을 참조할 수 있음
  - req: http.IncomingMessage의 인스턴스에서 요청 정보나 쿠키를 참조
  - res: http.ServerResponse의 인스턴스에서 쿠키를 설정하거나, 응답 헤더를 치호나할 때 사용
  - resolvedUrl: 실제 접근이 있던 경로
  - query: 해당 쿼리를 객체로 만든 것

### ISR을 통한 페이지 구현
- getStaticProps에서 revalidate를 반환하면 그 값이 유효기간이 도며, 유효 기간이 지난 페이지는 재생성됨
- 가장 처음으로 페이지에 접근한 경우 폴백 페이지가 표시되고, 서버 측에서 실행한 getStaticProps를 기반으로 클라이언트에서 다시 화면을 그림
- 이후 요청에 대해서는 revalidate에서 지정한 시간 내에는 서버 사이드에서 그려서 저장하고 있던 페이지를 반환
- 유효기간이 지난 뒤 요청이 있는 경우, 해당 요청에 대해서는 현재 저장돼 있는 페이지를 반환
- 그리고 getStaticProps를 실행하고 페이지를 그려 새로운 캐시로 저장

## Next.js의 기능
### 링크
- Next.js에서는 애플리케이션 안의 다른 페이지로 이동하기 위한 Link 컴포넌트가 있음
- Link 컴포넌트를 사용해 페이지를 이동하는 경우, 클라이언트 사이드에서 새로운 페이지를 그림
- 새로운 페이지를 그리기 위해 필요한 데이터는 미리 비동기 방식으로 얻어, 페이지를 빠르게 이동할 수 있음
- `<a>` 태그를 Link 태그로 감싸면 됨
- 쿼리 파라미터도 지정하는 경우, href 문자열로 그대로 지정하는 방법 외에 객체를 사용해 지정할 수도 있음
- a 요소 대신 버튼 등을 사용하면 Link의 자식 컴포넌트에 onClick 콜백이 전달되어, 콜백이 호출되면 페이지를 이동함
- 또한 router 객체의 push 메서드를 호출해 페이지를 이동할 수도 있음
  - router 객체에는 리도드를 수행하는 reload(), 페이지를 돌아가기 위한 back(), 페이지 이동 시작/종료 이벤트를 구독하는 메서드 등이 있음

### 이미지 표시
- Next.js에서 이미지를 표시할 때는 next/image의 Image 컴포넌트를 사용해야 함
- img 태그가 아닌 Image 컴포넌트를 사용함으로써, 이미지를 읽을 때 서버 사이드 이미지를 최적화함
- Image 컴포넌트를 사용하면 브라우저의 정보를 기반으로 최적화한 이미지를 제공함
- Image 컴포넌트는 초기 단계에서 뷰포트에 표시되지 않는 이미지는 그리지 않고, 스크롤해 뷰포트에 가까워진 단계에서 화면을 얻고 그리기 시작함
- 이미지를 로딩하는 동안에는 이미지를 표시하라 영역을 확보
- Image 컴포넌트는 몇 가지 파라미터를 props에 전달 할 수 있음
- 외부 리소스 이미지를 표시하는 경우에도 src에 문자열 경로를 지정할 수 있음
  - 다음 2가지 사항에 주의해야 함
  - 첫 번째는 정적 파일과 달리 이미지 크기를 사전에 얻을 수 없기 때문에, layout이 fill 이외인 경우에는 width와 height를 부여해야함
  - 두 번째는, 기본적으로 최적화한 이미지를 표시할 수 없음
  - 따라서 next.config.js의 domains에 최적화를 허가하는 이미지의 도메인을 추가하거나, Image 컴포넌트의 unoptimized에 true를 전달해 최적화를 무효화해야 함

### API 라우터
- pages/api 아래에 놓인 파일에서 API를 정의함
- 파일 위치에 따라 경로가 결정됨
- 빌드 시에는 이 API를 사용할 수 없으므로, SSG의 getStaticPaths나 getStaticProps로부터 호출할 수 없음

### 환경 변수/구성
- Next.jsㄴ느 내부적으로 환경 변수를 위한 .env 파일을 처리할 수 있음
- 로딩된 환경 변수는 서버 사이드에서 실행하는 처리에서 참조할 수 있음
- getServerSidePrps 등의 함수나 API 핸들러, 빌드 중 SSG 페이지를 그릴 때, SSR 페이지를 서버 사이드에서 그릴 때 환경 변수의 값을 참조할 수 있음
- 클라이언트 사이드에서도 접근하고 싶은 값에 대해선 환경 변수 이름 앞에 NEXT_PUBLIC_을 붙임

# 컴포넌트 개발
## 아토믹 디자인을 통한 컴포넌트 설계
- 프로젝트 전체에 지표가 있으면, 분할의 규모나 작동에 관해 일정 수준의 합의를 기반으로 개발할 수 있음
- 이런 지표로 아토믹 디자인이 자주 사용되고 있음

### 프레젠테이션 컴포넌트와 컨테이너 컴포넌트
- 형태와 작동을 분리함으로써, 각각의 책임을 명확하게 나눌 수 있고, 테스트나 디버그가 쉬워지므로 코드의 유지 보수성도 높일 수 있음
- 프레젠테이션 컴포넌트
  - 형태를 구현하는 컴포넌트
  - 기본적으로 props로 전달된 데이터를 기반으로 적절한 UI 부품을 표시하기만 함
  - 스타일 적용도 이 컴포넌트에서 수행
  - 프레젠테ㅣ션 컴포넌트 안에서는 내부에 상태를 갖지 않고, API 호출 등의 부가 작용을 실행하지 않음
  - props만 존재하므로, 같은 props에 대해 항상 같은 것이 표시되므로, 디자인에 관해 쉽게 디버그를 할 수 있음
  - 디자인만을 수정하고자 할 경우에도, 작동이나 외부의 영향을 고려할 필요가 없음
- 컨테이너 컴포넌트
  - 비즈니스 로직만 담당
  - Hooks를 가지며, 상태를 사용해 표시 내용을 전환하거나 API 호출 등의 부가 작용을 실행하는 등의 작동을 구현
  - Context를 참조해 프레젠테이션 컴포넌트에 대한 표시에 필요한 데이터를 전달

### 아토믹 디자인
- 아토믹 디자인은 본래 디자인 시스템을 구축하기 위한 방법론임
- 디자인을 계층적으로 정의함으로써, 일관성을 유지하고 관리가 쉽도록 함
- 디자인을 5계층으로 나누고, 아래 계층의 요소를 조합해 위 계층의 요소를 구성함
  - 아톰: 최소 요소. 더이상 분할할 수 없음. ex) 버튼, 텍스트
  - 몰리큘: 여러 아톰을 조합해 구축 ex) 라벨이 붙은 텍스트 박스
  - 오거니즘: 몰리큘보다 큰 구체적인 요소 ex) 입력폼
  - 템플릿: 페이지 전체의 레이아웃 ex) 페이지 레이아웃
  - 페이지: 페이지 그 자체
- 각 계층에서 프로그램적으로 어떤 역할/작동을 해야 하는지는 정의하지 않음

