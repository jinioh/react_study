# Next.js와 타입스크립트를 활용한 모던 개발
## Next.js와 타입스크립트
- Next.js는 리액트 기반으로 하지만, 프론트엔드 뿐만 아니라 서버 기능도 일부 갖고 있음
- 기존 리액트 애플리케이션은 모든 콘텐츠를 클라이언트 사이드인 브라우저에서 렌더링함
- Next.js를 활용해 리액트의 기능을 서버 사이드에서 렌더링되는 애플리케이션으로 확장 가능

### SPA의 등장과 MVC/MVVM 프레임워크
- SPA란 기동 시 한 차례 HTML 전체를 로드하고, 이후에는 사용한 인터렉션에 맞춰 Ajax로 정보를 얻고, 동적으로 페이지를 업데이트 하는 웹 애플리케이션
- 브라우저의 URL을 지정해 서버로부터 콘텐츠를 반환하는 기존 방식이 아니라, SPA에서는 페이지 이동을 클라이언트 사이드에서 수행
- 이때 Ajax를 사용해, 필요할 때 필요한 부분만 데이터를 얻어 뷰를 표시해 오버헤드 줄어듬
- SPA 이전에는 자바 스트럿츠나 루비온레일즈 등 서버 사이드 MVC 프레임워크가 제공하는 뷰 기능을 활용해 일반적으로 UI를 구현
  - 이 형식은 서버 사이드가 뷰(HTML)까지 담당하고, HTML 전체를 클라이언트 사이드에 전달
- SPA가 등장함에 따라 JSON 형식의 API가 서버와 프런트 연결을 담당
- SPA를 도입하는 장점
  - 고성능 애플리케이션 제공
  - 서버 사이드 엔지니어와 프런트엔드 엔지니어의 분업이 쉬어짐
  - JSON API를 통해 느슨한 결합의 설계 가능
  - IOS나 안드로이드 등 네이티브 애플리케이션 클라이언트에 대해서도 API를 통한 느슨한 결합 시스템 구성
- 단점
  - 자바스크립트 읽기와 랜더링이 발생해, 이에 대한 대책이 없으면 초기 표시에 다소 시간이 걸림
  - 학습 비용 발생
  - 프론트 코드량이 많아짐
- SPA는 다음과 같은 기술 요소로 구성
  - URL 경로와 뷰의 라우팅 관리
  - 클라이언트 사이드에서의 브라우저 이력 관리를 통한 페이지 이동
  - 비동기를 통한 데이터 얻기
  - 뷰 렌더링
  - 모듈화된 코드 관리
- 라우팅 라이브러리를 사용함으로써 URL마다 특정한 컴포넌터를 분류하고, 표시를 바꾸어 페이지 이동을 구현하기 위한 작동이 가능

### MVC/MVVM 자바스크립트 라이브러리 난립 시대
- MVVM이란 데이터를 관리하는 Model, 화면 표시와 관련된 View, 데이터와 표시의 가교 역할을 하는 ViewModel을 사용한 아키텍처
- MVVM 모델로부터 뷰로 데이터를 연동하고, 뷰로부터 모델로 데이터의 양방향 바인딩을 수행하는 아키텍처로, DOM 조작 코드를 작성하지 않고도 데이터 변경 변영가능
- 그리고 UI로부터 정보 입력이 데이터와 자동으로 동기화됨에 따라 생산성 높은 프런트 엔드 구현
  - AngularJS, KnockutJs, Riot.js, Vue.js

### 리액트의 등장과 컴포넌트 지향/상태 관리
- 가상 DOM
- 대규모 상태 관리 Flux
  - 양방향 데이터 바인딩을 활용하면 코드가 간략해지는 장점은 있지만, 지나치게 사용하면 어디의 변경이 어디에 영향을 미치는지 추적이 어렵고, 코드의 복잡성이 높아질 수 있음
  - 2014년 페이스북이 플럭스 애플리케이션 아키텍처 제안
  - 플럭스를 사용하면 데이터 흐름을 단방향으로 한정
  - 현재는 플럭스를 발전적으로 계승한 리덕스 라이브러리가 인기

### SSR/SSG의 필요성
- SSR
  - 서버사이드 랜더링은 서버 사이드 자바스크립트 실행 환경에서 요청에 대한 페이지를 생성해 HTML을 반환하는 것
  - 리액트는 보통 사용자의 브라우저가 자바스크립트를 실행하고, JSON을 기반으로 페이지를 구축
  - SSR은 서버 측에서 이를 수행하고, HTML을 생성해 반환
  - 장점
    - 랜더링을 서버 사이드에서 수행한 결과를 반환해, 사이트를 빠르게 표시
    - 서버 사이드에서 콘텐츠를 생성하므로, SPA에서는 복잡했던 SEO를 향상시킬 수 있음
  - 단점
    - Node.js등 서버사이드 자바스크립트 실행 환경 필요
    - 서버 사이드에서 렌더링하므로 서버 CPU 부하 증가
    - 서버와 클라이언트에서 자바스크립트의 로직이 분산될 가능성 있음
- SSG
  - 정적 사이트 생성은 사전에 정적 파일로서 생성, 배포하는 구조

### Next.js 등장
- 기존 모던 웹 애플리케이션을 개발할 땐 르액트 기반의 React Router를 사용해, SPA로 랜더링하는 것이 주류였음
- Next.js는 애플리케이션 특징에 맞춰 페이지의 렌더링을 서버 측에서 수행할 수 있기 때문에, SEO나 성능 측면에서 뛰어남

## 모던 프런트엔드 개발의 설계 사상
### 컴포넌트 지향
- 컴포넌트 설계
  - DRY 프로그래밍 원칙에 따름
  - 장점
    - 부품 재사용을 쉽게 (느슨한 결합)
    - 글로벌을 오염시키지 않음
    - 코드가독성 증가
    - 테스트 쉬워짐
  - 컴포넌트는 가능한 추상적이어야 함
  - 서비스나 기능 고유의 로직을 포함하는 UI 부품을 구현해버리면 재사용성이 낮아져 컴포넌트 장점을 얻을 수 없음
  - 컴포넌트 지향으로 구현한다는 의미는, 가능한 기초적인 컴포넌트 부품을 재사용 가능한 형태로 애플리케이션 콘텍스트에 의존하지 않는 형태로 구현하는 것을 의식함
- 컴포넌트 상태 관리
  - props: 컴포넌트의 외부에서 받을 수 있는 값. 컴포넌트 안에서 무언가 트리거될 때 호출되는 함수도 전달 할 수 있음
  - state: 컴포넌트 내부에서 저장하는 데이터. props와 달리 컴포넌트 외부에서 값을 전달할 수 없으며, 외부로부터 접근할 수 없음
  - props는 단방향 데이터 흐름 구조를 갖는 것이 특징이고, state는 반드시 해당 컴포넌트 자신 및 하위의 컴포넌트에만 영향을 미침
  - 이 원칙을 지킴으로써 데이터를 위에서 아래 방향으로 항상 전달하는 것이 약속되며, 역방향으로는 전달할 수 없으므로, 예상치 못한 부가 작용을 피할 수 있음 (느슨한 결합)
  - 컴포넌트의 state를 업데이트 하려면 훅이라 불리는 기능의 하나인 useState 사용
- 컴포넌트 사이의 데이터 전달
  - 간단한 용도라면 props를 통해 콜백을 주고 받는 방법을 사용할 수 있음
    - 콜백 함수를 사용한 코드는 복잡해지기 마련
  - Flux 또는 Context로 애플리케이션 안의 데이터를 효율적으로 수행
  - Context를 사용하는 목적은 props에 따른 버킷 릴레이를 피하는 것
  - Context는 Provider를 지정한 리액트 컴포넌트 아래의 트리에 대해 '글로벌'로 접근할 수 있는 구조이기 때문에, 너무 많이 사용하면 가독성을 떨어뜨릴 수 있음
- 스토리북: 컴포넌트의 카탈로그화
  - 컴포넌트를 누구나 확인할 수 있는 형태로 카탈로그화함으로써 양쪽의 인식 차이를 줄일 수 있음
  - 장점
    - 컴포넌트 설계를 강제화
    - 컴포넌트 UI를 쉽게 확인
    - 개발자 사이에서의 분업을 쉽게
    - 디자이너, 엔지니어 사이에서 공통 인식을 쉽게 맞출 수 있음
    - 컴포넌트에 전달하는 값을 동적으로 변경해 작동을 확인
    - 컴포넌트 단위 테스트/스냅샷 테스트를 쉽게

### Next.js가 필요해진 이유
- Next.js 개발자들의 사상은 클라이언트와 서버 사이에서 코드를 공유할 수 있는 유니버셜한 자바스크립트 애플리케이션을 만드는 것

## 타입스크립트 기초지식
### 타입스크립트오 자바스크립트의 차이
- 타입스크립트는 자브사크립트에 주로 다음 기능을 추가한 것
  - 타입 정의
  - 인터페이스와 클래스
  - null/undefined-safe
  - 범용적인 클래스나 메서드 타입을 실현하는 제네릭
  - 편집기의 입력 자동 완성
  - 그외, ECMA에서 정의되어 있는 자바스크립트의 최신 사양

## 기본적인 타입 기능
### 타입 추론
### 타입 어서션
- 타입 어서션을 인정하는 것은 대상이 되는 타입보다 구체적이거나 범용적인 타입으로 변환하는 경우
- 타입 어서션은 실행 시 에러를 일으킬 가능성이 있으므로 주의

### 타입 앨리어스
- 이름을 참조해 같은 타입을 여러 차례 재사용 할 수 있음
- 인덱스 타입 앨리어스
  - 키 이름을 명시하지 않고 타입 앨리어스 정의

### 인터페이스
- 타입 앨리어스와 비슷하지만, 보다 확상성이 높은 열린 기능을 갖고 있음
- 나중에 인터페이스를 확장할 수 있다. 타입 앨리아스는 안됨
- 타입스크립트를 설계 사상을 고려했을 때 인터페이스와 타입 앨리어스 기능은 다소 다른 점이 있다
- 인터페이스는 클래스나 데이터의 한쪽 측면을 증어한 타입. 즉, 인터페이스에 매치하는 타입이라도 그 값 이외에 다른 필드나 메서드가 있음을 전재로 함
- 타입 앨리어스는 객체의 타입 자체를 의미
- 객체 그 자체가 아니라 클래스나 객체의 일부 속성이나 함수를 포함하는 일부 작동을 정의할 때는 인터페이스를 사용하는 것이 적합

### 클래스

## 실제 개발 시 중요한 타입
### Enum 타입
- 수치 기반 이외에 문자열 기반 Enum 타입도 사용가능

### 제네릭 타입
- 바깥쪽에서 지정된 타입이 달라도 작동하도로 할 수 있는 범용적인 클래스나 함수를 정의할 때 편리

### Union 타입과 Intersection 타입
- 타입스크립트는 타입을 조합해 사용할 수 있음
- 각각 |와 & 사용
- Intersection 타입은 여러 타입을 병합해 하나로 만든타입을 생성

### 리터럴 타입
- |로 데이터를 구분하는 리터럴 타입을 사용하면 정해진 문자열이나 수치만 대입할 수 있는 타입으로 제어 가능
- 데이터의 상태를 나타내는 값 등에 사용 할 수 이씀
- enum이랑 뭔차이??

### never 타입
- 절대로 발생하지 않는 값의 종류
- 항상 예외를 발생시키는 함수 등에서 절대로 값이 반환되지 않는 반환값의 타입을 never로 지정할 수 있음

## 타입스크립트 테크닉
### 옵셔널 체이닝
- 중첩된 객체의 속성이 존재하는가에 관한 조건 분기를 간단하게 기술할 수 있음
- ?를 사용해 null 또는 undefined가 될 수 있는 객체에 대해 안전하게 처리를 기술

### 논-널 어서션 연산자
- 컴퍼일 옵션 --strictNullChecks를 지정해 컴파일하면, 타입스크립트는 일반적으로 null일 가능성이 있는 객체에 대한 잡근을 에러로 취급
- null이 아님을 나타내고 싶을 때는 논-널 어서션이라는 기능을 명시적으로 컴파일러에게 문제 없음을 전달할 수 있음
- !를 붙임

### 타입 가드
- if나 switch 문의 조건 분기에서 타입 체크를 수행할 때, 해당 조건 분기 블록 이후는 변수의 타입이 필터링되는 추론을 수행
- 실행 시 에러를 발생시키기 쉬운 as를 사용하는 타입 어서션보다 안전하게 타입을 사용한 코드를 작성할 수 있음

### keyof 연산자
- 타입에 keyof를 사용하면 해당 타입이 가진 각 속성의 타입의 Union 타입을 반환
- 객체에 존재하는 키를 사용해 무언가의 함수 처리를 수행하고자 할 때 안전하게 구현할 수 있음

### 인덱스 타입
- 객체의 속성이 변할 때, 모아서 타입을 정의할 수 있음
- 각 속성에 대응하는 타입을 정의할 수 없을 때 간단하게 기술할 수 있음

### readonly
- readonly가 지정된 속성은 변경할 수 없음
- const는 변수의 대입에 대해 수행하는 선언, readony는 객체나 클래스의 속성에 대해 수행하는 선언으로 컴파일 시 에러를 감지할 수 있다. 
- Readonly 타입이라는 제네릭 타입도 있음

### unkown
- any와 마찬가지로 모든 값을 대입할 수 있는 타입
- 대입된 값 상태 그대로는 임의의 함수나 속성으로 접근불가

### 비동기 Async/Await
- 비동기 처리 API인 Promise의 간략한 구문에 해당하는 것이 Async/Await의 기능
- await 구문을 사용하기 위해선 async function 안에서 호출해야 함

### 타입 정의 파일
- 타입스크립트에서는 자바스크립트 라이브러리를 로딩해 실행할 수 있지만, 타입정의 정보가 없을 때는 타입 안전한 코드를 작성할 수 없음
- 그래서 타입스크립트에는 자바스크립트 모듈에 대해, 타입 정보를 부여할 수 있는 타입 정의 파일이라는 구조를 제공
- 타입 정의 파일 도입
  - `@types/[라이브러리명]`으로 공개된 타입 정의 파일을 설치
- 타입 정의 파일 작성
  - 의존하는 자바스크립트의 라이브러리가 타입 정의 파일을 포함하고 있지 않거나, 공개돼 있지 않을 때, 직접 .d.ts라는 확장자를 가진 타입 정의 파일을 설치하고 로딩해 사용

## 타입 스크립트 개발 시 설정
### tsconfig.json
- 컴피일에 필요한 옵션이나 컴파일 대상이 되는 파일의 정보등을 기술
- tsc --init 명령어를 실행하면 기본 tsconfig.json 파일 생성됨
- 프로젝트 루트에 배치

### Prettier
- 공통 코드 포맷
- npm install prettier --save-dev 로 설치
- 프로젝트 디렉터리 아래 .prettierrc 파일이 생성됨
- `npm run prettier-format`명령어로 src 아래의 모든 타입스크립트 소스에 대해 포매팅이 실행됨

### ESLint
- 코드를 해석해 문제가 있는 위치를 지적해 코드 품질을 높이는 데 도움을 줌
- .eslintrc.js 파일

### 컴파일 옵션
- noImplicitAny
  - 암묵적인 any를 사용한 경우 에러발생하도록
- target
  - 타입스크립트가 컴파일을 수행할 때 어떤 버전의 ECMAScript로 출력할 것인지 지정가능

### 코딩 스타일 가이드
- 자바스크립트 표준 스타일
- 에어비앤비 스타일
- 구글 스타일
- TypeScript Deep Dive 스타일

# 리액트/Next.js 기초
## 리액트 입문
### 리액트 시작하기
- npx create-react-app [프로젝트명] --template typescript

### 리액트 기본
- 브라우저에서 페이지가 표시될 때, 다음의 순서를 통해 실제 리액트에 작성된 내용이 반영됨
  - public/index.html을 로딩해 브라우저에 그림
  - 브라우저가 자바스크립트 코드를 얻어, 리액트를 사용한 코드의 실행을 시작
  - render()에 주어진 App을 root 객체 작성 시 주어진 root라는 ID를 가진 요소 아래 그림
- 리액트의 기본 키워드
  - 웹 페이지에 리액트로 생성한 내용을 표시하려면 ReacDOM.createRoot에 컨테이너를 전달해 root 객체를 생성하고, render 메서드에 요소를 전달

## 리액트에서의 컴포넌트
- 컴포넌트로 구현한 내용은 최종적으로 브라우저에서는 대응하는 HTML 태그 등으로 변환되어 표시됨
- JSX 코드는 브라우저에서는 직접 해석할수 없으므로, 웹팩에 의해 자바스크립트 코드로 변환됨
- 이때 JSX로 구현된 컴포넌트는 자바스크립트의 객체로 표현됨
- 변환된 자바스크립트 코드를 브라우저가 읽어 실행하고 화면을 그리기 시작
- 리액트의 화면 그리기 엔진에서는 먼저 가상 DOM을 구현함
- 그리고 앞에서 구현할 떄의 가상 DOM과 비교해, 차이가 있는 부분만 실제 DOM을 업데이트

### 리액트 요소
- JSX는 중괄호{}를 사용해 자바스크립트의 값을 삽입할 수 있음

### 컴포넌트
- 함수나 클래스를 사용해 구현하나, 현재는 주로 함수 컴포넌트를 사용
- 컴포넌트 이름은 대문자로 시작
- 컴포넌트에 외부에서 값을 전달하려면 props를 사용
  - props는 컴포넌트를 사용한 부모로부터 전달되는 데이터
  - 컴포넌트를 사용하는 측은 같은 이름으로 데이터를 전달
- props는 부모로부터 자식에게 한 방양으로 데이터를 전달하는 것
- props의 내용을 자식이 치환할 수 없고, 시도하면 에러 발생

## 리액트에서의 타입
- 함수 컴포넌트는 임의의 객체를 props로서 인수로 가지며, JSX.Element 타입의 값을 반환하는 함수가 됨
- 그러므로 인수인 props에 타입 애터테이션을 붙여 부모 컴포넌트로부터 받을 수 있는 값을 제한할 수 있음

## Context
- 데이터를 전달하는 또 한가지 방법으로 Context가 있음
- Context를 사용하면 데이터를 부모로부터 직접 전달하지 않아도 컴포넌트가 필요한 데이터를 참조할 수 있음
- 예를 들어 로그인한 사용자 정보는 여러 컴포넌트에서 사용될 수 있어 props보단 Context 사용
- Provider와 Consumer라는 2개의 컴포넌트를 사용
- 먼저 createContext()로 Context 작성
- 데이터를 전달할 때는 Context.Provider 컴포넌트의 props인 Value에 데이터를 전달
- 데이터를 참조할 때는 Context.Consumer 컴포넌트를 추가하고, 그 자식 요소로서 함수를 지정하면 인수로부터 데이터를 참조 할 수 있음

## React Hooks
- 함수 컴포넌트 안의 상태난 라이프사이클을 다루기 위한 기능
- 컴포넌트 안의 상태와 로직을 훅으로 추출해, 컴포넌트 코드를 깔끔하게 유지할 수 있음
### useState와 useReducer - 상태 훅
- 이 훅들을 사용하면 컴포넌트는 내부 상태를 가지며, 해당 상태의 변화에 따라 표시를 변경할 수 있음
- useState
  - useState(초기값)로 하나의 새로운 상태를 작성
  - 첫 번째 인수에 전달한 값이 초기 상태가 됨
  - 반환값은 배열임
    - 배열의 첫 번째에 현재 상태를 유지할 변수
    - 두 번째에 업데이트 함수를 입력
  - 업데이트 함수를 호출하면 상태가 바뀌고, 훅이 있는 컴포넌트는 다시 그려짐
  - 업데이트 함수를 호출하라 때는 인수에 값을 전달하는 방법과, 함수를 전달하는 방법이 있음
    - 값을 전달하면 해당 값이 다음 상태가 되며, 함수를 전달하면 함수의 반환값이 다음 상태가 됨
  - 새로 업데이트 할 값이 이전 스테이트와 연관되어 있다면 setState에 콜백함수를 넣는게 좋음. 콜백 인자로는 이전 값들이 들어가게됨
  - 초기값을 가져올때 useState에 무거운 작업이 발생한다면 콜백함수를 사용해 1번만 호출되도록
- useReducer
  - 상태를 다루기위한 또 하나의 훅
  - 복잡한 상태 전이를 간단하게 기술 할 수 있음
  - 또한 배열아나 객체 등의 여러 데이터를 모은 것을 상태로 다루는 경우 많이 사용
  - useState는 업데이트 함수에 다음 상태를 직접 전달했지만, useReducer에서는 업데이트 함수(dispatch)에 action이라는 데이터를 전달
  - useReducer()의 반환값 배열의 첫 번째는 현재 상태, 두 번째는 dispatcher 함수
  - useReducer의 첫 번째 인수에는 reducer함수, 두 번째에는 초깃값을 전달
  - setState()에 비해, 상태 업데이트를 호출하는 방법은 구체적인 상태에 의존하지 않기 때문에 코드를 간단하게 유지할 수 있음
  - 상태를 업데이트하는 로직을 컴포넌트 밖의 함수로 추출하기 때문에 테스트도 쉬워짐

### useCallback과 useMemo - 메모이제이션 훅
- 값이나 함수를 유지하고, 불필요한 자식 요소의 렌더링이나 계산을 덕제하기 위해 사용
- 부모 컴포넌트가 다시 그려지면 무조건 자식 컴포넌트는 다시 그려짐
- 다시 그리기가 전파되는 것을 막기 위해, 메모이제이션 컴포넌트를 사용
- 메모이제이션 컴포넌트는 부모 컴포넌트에서 화면 다시 그리기가 발생했을 때도, props나 context 값이 바뀌지 않은 경우 화면 다시 그리기가 발생하지 않음
- 메모이제이션 컴포넌트에 함수나 객체를 전달하면, 다시 부모의 화면이 다시 그려질 때 컴포넌트 역시 다시 그려짐
- 컴포넌트 성능개선에 사용됨
- useCallback
  - 함수를 메모이제이션 하기 위한 훅
- useMemo
  - 값을 메모이제이션 (동일한 값을 재사용할 때)
  - 함수형 컴포넌트는 랜더링 --> Component 함수 호출 --> 모든 내부 변수 초기화
  - 처음 계산된 결과를 메모리에 저장 후 재사용
  - 2개 인자 받음
    - 첫번째 콜백함수 (유즈메모가 리턴하는 값)
    - 두번째 배열 (의존성배열): 요소의 값이 업데이트 될 때 콜백함수 실행
  - 꼭 필요할 때만 사용

### useEffect와 useLayoutEffect - 부가 작용 훅
- useEffect
  - 부가 작용을 실행하기 위해 사용하는 훅
  - Mount, Update, Unmount와 관련
  - 인자로 콜백함수를 받음. 원하는 작업을 작성
  - 콜백함수만 받는거나, 콜백함수 + 배열을 받거나
    - 첫번째는 랜더링 될때 마다 실행
    - 두 번째는 맨처음 화면 랜더링 될때와 value 값이 바뀔때 실행
        - 빈배열 전달하면 처음에 랜더링 될 때만 실행
        - 여기서 배열은 디팬던시 배열임
  - return 값을 작성해주면 언마운트 될 때 실행 됨. 정리 작업을 작성할 수 있음
- useLayoutEffect
  - 부가 작용을 실행하기 위한 훅이지만, useEffect와 실행 시점이 다름

### useContext - Context를 위한 훅
- useContext
  - 전역적인 데이터를 props로 전달하면 힘들 수 있음
    - Prop Drilling
  - 상위에서 사용하고 싶은 하위 컴포넌트에 방송해 줄 수 있음
  - Context는 꼭 필요할 떄만 사용
    - Context를 사용하면 컴포넌트를 재사용하기 어려워 질 수 있음
    - Prop Drilling을 피하기 위한 목적이라면 Component Composition을 먼저 고려

### useRef와 useImpreativeHandle - ref 훅
- useRef(value)
  - ref 오브젝트를 반환 {current: value}
  - unmout 될 때 까지 값을 유지할 수 있음
    - 일반 변수랑 다른점은 일반 변수는 화면이 초기화 될 때 값도 초기화됨
  - ref가 수정되도 다시 랜더링 하지 않음
    - 무한 랜더링 방지할 수 있음
    - 값의 변화가 랜더링을 발생시키고 싶지 않을 때 편리
  - 유용한 상황
    - 저장공간으로 사용: Ref가 변화 --> No 렌더링 --> 변수들의 값 유지 (변경시 랜더링이 발생하지 말아야 할 상황을 다룰 때)
    - DOM 요소에 접근

### 커스텀 훅과 useDebugValue

## Next.js 입문
- 